class PluginFactory : public nvinfer1::IPluginFactoryV2, public nvuffparser::IPluginFactory
{
public:
    virtual nvinfer1::IPluginV2* createPlugin(const char* layerName, const nvinfer1::Weights* weights, int nbWeights, const nvuffparser::FieldCollection fc) override
    {
        std::cout << "createPlugin (layerName, weights, nbWeights)" << std::endl;
        std::cout << "name is " << layerName << std::endl;
        if (isBilinearPlugin(layerName))
        {
            mPluginResizeBilinear = std::unique_ptr<BilinearUpsamplingPlugin>(new BilinearUpsamplingPlugin(weights, nbWeights));
            return mPluginResizeBilinear.get();
        }
        else if (isNearestPlugin(layerName))
        {
            mPluginResizeNearest = std::unique_ptr<NearestNeighborUpsamplingPlugin>(new NearestNeighborUpsamplingPlugin(weights, nbWeights));
            return mPluginResizeNearest.get();
        }
        else
        {
            assert(0);
            return nullptr;
        }
    }

    IPluginV2* createPlugin(const char* layerName, const void* serialData, size_t serialLength) override
    {
        std::cout << "createPlugin (layerName, serialData, serialLength)" << std::endl;
        std::cout << "name is " << layerName << std::endl;
        std::cout << "length is " << serialLength << std::endl;
        if (isBilinearPlugin(layerName))
        {
            mPluginResizeBilinear = std::unique_ptr<BilinearUpsamplingPlugin>(new BilinearUpsamplingPlugin(serialData, serialLength));
            return mPluginResizeBilinear.get();
        }
        else if (isNearestPlugin(layerName))
        {
            mPluginResizeNearest = std::unique_ptr<NearestNeighborUpsamplingPlugin>(new NearestNeighborUpsamplingPlugin(serialData, serialLength));
            return mPluginResizeNearest.get();
        }
        else
        {
            assert(0);
            return nullptr;
        }
        mPluginResizeNearest = std::unique_ptr<NearestNeighborUpsamplingPlugin>(new NearestNeighborUpsamplingPlugin(serialData, serialLength));
        return mPluginResizeNearest.get();
    }

    bool isPlugin(const char* name) override
    {
        return isBilinearPlugin(name) || isNearestPlugin(name);
    }

    bool startsWith(const char* name, const char* prefix)
    {
        return !strncmp(name, prefix, strlen(prefix));
    }

    bool isBilinearPlugin(const char* name)
    {
        return startsWith(name, "_ResizeBilinear");
    }

    bool isNearestPlugin(const char* name)
    {
        return startsWith(name, "_ResizeNearestNeighbor");
    }

    // The application has to destroy the plugin when it knows it's safe to do so.
    void destroyPlugin()
    {
        std::cout << "destroy plugin factory" << std::endl;
        mPluginResizeBilinear.reset();
        mPluginResizeNearest.reset();
    }

    std::unique_ptr<BilinearUpsamplingPlugin> mPluginResizeBilinear{nullptr};
    std::unique_ptr<NearestNeighborUpsamplingPlugin> mPluginResizeNearest{nullptr};
};
